# Learnings

Distilled patterns and gotchas for future agents working on anki-renderer.

## Project Structure

- **Type**: Rust → WASM library with npm package
- **Main crate**: `anki-renderer` in root
- **WASM output**: `pkg/` directory (generated by wasm-pack, gitignored)
- **Entry point**: `src/lib.rs`

## Commands

```bash
# Local development
cargo build              # Build Rust
cargo test               # Run tests
cargo clippy -- -D warnings  # Lint

# WASM build
wasm-pack build --target web --out-dir pkg

# Package verification
cd pkg && npm pack
```

## CI

- GitHub Actions at `.github/workflows/ci.yml`
- Runs: lint → test → wasm-pack build → verify .wasm exists
- Uses `dtolnay/rust-toolchain@stable` (NOT rust-action)

## Patterns

- All exported functions need `#[wasm_bindgen]` attribute
- Prefix unused parameters with `_` to avoid lint warnings
- `JsError` is the WASM-compatible error type

## Cloze Implementation

- Cloze syntax: `{{c1::text}}` or `{{c1::text::hint}}`
- Card ordinal is 1-indexed (c1 = card 1, c2 = card 2)
- Question side: hidden cloze shows `[...]` or `[hint]`
- Answer side: revealed cloze shows text with `<span class="cloze">` wrapper
- Use `{{cloze:FieldName}}` filter in templates

## Template Filters

Available filters in `src/filters.rs`:
- `text` - strips HTML tags (converts `<br>` to newlines)
- `hint` - generates clickable reveal element
- `type` - generates input field for answer comparison
- `furigana` - converts bracket syntax `漢字[かんじ]` to ruby HTML
- `kanji` - extracts base text from ruby annotations
- `kana` - extracts readings from ruby annotations

Filter behavior:
- Filters apply right-to-left: `{{text:hint:Field}}` applies hint first, then text
- Unknown filters pass through unchanged (graceful fallback)
- Filter names: alphanumeric, hyphen, underscore allowed

## Gotchas

- The action is `dtolnay/rust-toolchain` not `rust-action`
- wasm-pack installer script requires rustup to be visible in PATH
- `JsError::new()` only works in WASM - use native error types for non-WASM tests

## rslib Dependency Analysis (Issue #2)

### Core Files for Template Rendering

| File | Lines | Purpose |
|------|-------|---------|
| `template.rs` | ~1400 | Main template parser and renderer |
| `template_filters.rs` | ~300 | Filter implementations (text, furigana, hint, tts, cloze) |
| `cloze.rs` | ~850 | Cloze deletion parsing and rendering |

### External Crates (Required)

- `nom` - Parser combinator (template syntax parsing)
- `regex` - Pattern matching (cloze, HTML, furigana)
- `htmlescape` - HTML attribute encoding
- `blake3` + `hex` - Hash generation for hint IDs
- `itertools` - Iterator utilities (cloze ordinals)

### Internal Dependencies (Need Stubs)

| Module | Usage | Stub Strategy |
|--------|-------|---------------|
| `anki_i18n::I18n` | Error messages, blank indicators | Simple string fallbacks |
| `crate::error` | `AnkiError`, `TemplateError` | Minimal custom error enum |
| `crate::text` | `strip_html`, `strip_html_preserving_entities` | Reimplement (~100 lines) |
| `crate::latex` | `contains_latex` | Simple regex check |
| `crate::image_occlusion` | Image cloze parsing | Defer to phase 2 |

### Proto Dependencies (Can Avoid)

Proto types are used for RPC service layer, not core rendering:
- `anki_proto::card_rendering` - Only needed for service boundary
- `anki_proto::image_occlusion` - Only for image occlusion feature

**Recommendation**: Avoid proto entirely. Define native Rust types for WASM interface.

### Minimal WASM Extraction Plan

**Phase 1 - Core Template Parsing**:
1. Port `template.rs` parser (lexer, AST, parser)
2. Port `template.rs` renderer (field substitution, conditionals)
3. Implement basic error types

**Phase 2 - Filters**:
1. Port `template_filters.rs` (text, furigana, kana, kanji, hint, type, tts)
2. Port `cloze.rs` cloze filter
3. Stub I18n with default strings

**Phase 3 - Full Cloze Support**:
1. Full `cloze.rs` implementation
2. Nested cloze support
3. Multi-card cloze support

**Deferred**:
- Image occlusion (complex, niche use case)
- TTS voice enumeration (platform-specific)
- LaTeX extraction (separate concern)

## JavaScript/TypeScript Bindings

Structure:
- `js/src/index.ts` - Main wrapper with high-level API
- `js/src/types.ts` - TypeScript type definitions
- `js/tests/` - Jest tests
- `dist/` - Compiled JavaScript output (gitignored)

Key patterns:
- FrontSide must be added to fields BEFORE rendering the back template
- WASM web target requires calling `init()`, Node.js target doesn't
- Use environment detection to load correct WASM build
- Export both low-level (`renderTemplate`) and high-level (`renderCard`) APIs

Build commands:
```bash
npm run build:wasm       # Web target → pkg/
npm run build:wasm:node  # Node target → pkg-node/
npm run build:ts         # TypeScript → dist/
npm run build            # All three
npm run test:js          # Jest tests
npm run test:e2e         # Playwright tests
```

## Web Component

The `<anki-card-preview>` custom element renders cards in the browser:
- Shadow DOM for style isolation
- Auto-registers on import in browser environments
- Events: `render-complete`, `render-error` with bubbles/composed true

Attributes:
- `template-front`, `template-back` - Template strings
- `fields` - JSON object of field values
- `side` - "question" or "answer"
- `card-ordinal` - Cloze card number (1-indexed)
- `css` - Custom CSS styles
- `night-mode` - Boolean, dark theme
- `default-styles` - Boolean, include Anki defaults

## CSS Styling

Structure:
- `js/src/styles.ts` - CSS constants and utilities
- `DEFAULT_ANKI_CSS` - Standard Anki card styles
- `NIGHT_MODE_CSS` - Dark theme styles

Key patterns:
- Anki uses `.card` as root CSS selector
- Night mode background: `#2f2f31` (dark gray)
- Use `renderStyledCard()` for complete styled output
- CSS dynamically injected into Shadow DOM via style element

Style options:
```typescript
{
  css: ".card { background: navy; }",  // Custom CSS
  includeDefaultStyles: true,          // Add DEFAULT_ANKI_CSS
  nightMode: true,                     // Add NIGHT_MODE_CSS + nightMode class
}
```

## AWS Deployment

The demo site is deployed to AWS, not GitHub Pages.

**Live site**: https://anki-renderer.bjblabs.com

### Infrastructure

| Resource | Value |
|----------|-------|
| S3 Bucket | `anki-renderer-demo-719390918663` |
| CloudFront Distribution | `E7ZBUOH7HRPA5` |
| Domain | `anki-renderer.bjblabs.com` |
| CDK Stack | `AnkiRendererDemoStack` |

### Stack Components

- **S3**: Private bucket, CloudFront-only access via OAC
- **CloudFront**: HTTPS, caching, custom domain
- **ACM**: TLS certificate, auto-validated via Route 53
- **Route 53**: A record alias to CloudFront

### Deployment Flow

```
Push to main → CI passes → Deploy workflow triggers → CDK deploy
```

The deploy workflow (`.github/workflows/deploy.yml`):
1. Builds WASM (web + node targets)
2. Builds TypeScript library
3. Builds demo site with Vite
4. Runs `cdk deploy` to update infrastructure and upload files

### CDK Infrastructure

Location: `/infra`

```bash
cd infra
npm install
npx cdk synth      # Preview CloudFormation template
npx cdk deploy     # Deploy (requires AWS credentials)
npx cdk diff       # Show pending changes
```

Key files:
- `bin/app.ts` - CDK app entry point, defines stack props
- `lib/static-site-stack.ts` - S3 + CloudFront + Route 53 stack

### AWS Authentication

GitHub Actions uses OIDC (no long-lived credentials):
- **IAM Role**: `github-actions-anki-renderer`
- **Trust**: Only `Gilbetrar/anki-renderer` repo can assume
- **Secret**: `AWS_ROLE_ARN` in GitHub repo settings

### Manual Deployment

If you need to deploy manually (not via CI):

```bash
# Ensure AWS credentials are configured
aws sts get-caller-identity

# Build everything
npm run build
cd demo && npm install && npm run build && cd ..

# Deploy
cd infra
npm install
npx cdk deploy
```

### Troubleshooting

**DNS not resolving**: Route 53 changes propagate quickly, but local DNS caches may hold stale records. Flush DNS cache:
```bash
sudo dscacheutil -flushcache; sudo killall -HUP mDNSResponder
```

**CloudFront 403 errors**: Check S3 bucket policy allows CloudFront OAC access.

**Certificate issues**: ACM certificates must be in `us-east-1` for CloudFront. The CDK stack handles this.
