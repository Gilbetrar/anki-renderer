# Learnings

Distilled patterns and gotchas for future agents working on anki-renderer.

## Project Structure

- **Type**: Rust → WASM library with npm package
- **Main crate**: `anki-renderer` in root
- **WASM output**: `pkg/` directory (generated by wasm-pack, gitignored)
- **Entry point**: `src/lib.rs`

## Commands

```bash
# Local development
cargo build              # Build Rust
cargo test               # Run tests
cargo clippy -- -D warnings  # Lint

# WASM build
wasm-pack build --target web --out-dir pkg

# Package verification
cd pkg && npm pack
```

## CI

- GitHub Actions at `.github/workflows/ci.yml`
- Runs: lint → test → wasm-pack build → verify .wasm exists
- Uses `dtolnay/rust-toolchain@stable` (NOT rust-action)

## Patterns

- All exported functions need `#[wasm_bindgen]` attribute
- Prefix unused parameters with `_` to avoid lint warnings
- `JsError` is the WASM-compatible error type

## Cloze Implementation

- Cloze syntax: `{{c1::text}}` or `{{c1::text::hint}}`
- Card ordinal is 1-indexed (c1 = card 1, c2 = card 2)
- Question side: hidden cloze shows `[...]` or `[hint]`
- Answer side: revealed cloze shows text with `<span class="cloze">` wrapper
- Use `{{cloze:FieldName}}` filter in templates

## Template Filters

Available filters in `src/filters.rs`:
- `text` - strips HTML tags (converts `<br>` to newlines)
- `hint` - generates clickable reveal element
- `type` - generates input field for answer comparison
- `furigana` - converts bracket syntax `漢字[かんじ]` to ruby HTML
- `kanji` - extracts base text from ruby annotations
- `kana` - extracts readings from ruby annotations

Filter behavior:
- Filters apply right-to-left: `{{text:hint:Field}}` applies hint first, then text
- Unknown filters pass through unchanged (graceful fallback)
- Filter names: alphanumeric, hyphen, underscore allowed

## Gotchas

- The action is `dtolnay/rust-toolchain` not `rust-action`
- wasm-pack installer script requires rustup to be visible in PATH
- `JsError::new()` only works in WASM - use native error types for non-WASM tests

## rslib Dependency Analysis (Issue #2)

### Core Files for Template Rendering

| File | Lines | Purpose |
|------|-------|---------|
| `template.rs` | ~1400 | Main template parser and renderer |
| `template_filters.rs` | ~300 | Filter implementations (text, furigana, hint, tts, cloze) |
| `cloze.rs` | ~850 | Cloze deletion parsing and rendering |

### External Crates (Required)

- `nom` - Parser combinator (template syntax parsing)
- `regex` - Pattern matching (cloze, HTML, furigana)
- `htmlescape` - HTML attribute encoding
- `blake3` + `hex` - Hash generation for hint IDs
- `itertools` - Iterator utilities (cloze ordinals)

### Internal Dependencies (Need Stubs)

| Module | Usage | Stub Strategy |
|--------|-------|---------------|
| `anki_i18n::I18n` | Error messages, blank indicators | Simple string fallbacks |
| `crate::error` | `AnkiError`, `TemplateError` | Minimal custom error enum |
| `crate::text` | `strip_html`, `strip_html_preserving_entities` | Reimplement (~100 lines) |
| `crate::latex` | `contains_latex` | Simple regex check |
| `crate::image_occlusion` | Image cloze parsing | Defer to phase 2 |

### Proto Dependencies (Can Avoid)

Proto types are used for RPC service layer, not core rendering:
- `anki_proto::card_rendering` - Only needed for service boundary
- `anki_proto::image_occlusion` - Only for image occlusion feature

**Recommendation**: Avoid proto entirely. Define native Rust types for WASM interface.

### Minimal WASM Extraction Plan

**Phase 1 - Core Template Parsing**:
1. Port `template.rs` parser (lexer, AST, parser)
2. Port `template.rs` renderer (field substitution, conditionals)
3. Implement basic error types

**Phase 2 - Filters**:
1. Port `template_filters.rs` (text, furigana, kana, kanji, hint, type, tts)
2. Port `cloze.rs` cloze filter
3. Stub I18n with default strings

**Phase 3 - Full Cloze Support**:
1. Full `cloze.rs` implementation
2. Nested cloze support
3. Multi-card cloze support

**Deferred**:
- Image occlusion (complex, niche use case)
- TTS voice enumeration (platform-specific)
- LaTeX extraction (separate concern)

## JavaScript/TypeScript Bindings

Structure:
- `js/src/index.ts` - Main wrapper with high-level API
- `js/src/types.ts` - TypeScript type definitions
- `js/tests/` - Jest tests
- `dist/` - Compiled JavaScript output (gitignored)

Key patterns:
- FrontSide must be added to fields BEFORE rendering the back template
- WASM web target requires calling `init()`, Node.js target doesn't
- Use environment detection to load correct WASM build
- Export both low-level (`renderTemplate`) and high-level (`renderCard`) APIs

Build commands:
```bash
npm run build:wasm       # Web target → pkg/
npm run build:wasm:node  # Node target → pkg-node/
npm run build:ts         # TypeScript → dist/
npm run build            # All three
npm run test:js          # Jest tests
npm run test:e2e         # Playwright tests
```

## Web Component

The `<anki-card-preview>` custom element renders cards in the browser:
- Shadow DOM for style isolation
- Auto-registers on import in browser environments
- Events: `render-complete`, `render-error` with bubbles/composed true

Attributes:
- `template-front`, `template-back` - Template strings
- `fields` - JSON object of field values
- `side` - "question" or "answer"
- `card-ordinal` - Cloze card number (1-indexed)
- `css` - Custom CSS styles
- `night-mode` - Boolean, dark theme
- `default-styles` - Boolean, include Anki defaults

## CSS Styling

Structure:
- `js/src/styles.ts` - CSS constants and utilities
- `DEFAULT_ANKI_CSS` - Standard Anki card styles
- `NIGHT_MODE_CSS` - Dark theme styles

Key patterns:
- Anki uses `.card` as root CSS selector
- Night mode background: `#2f2f31` (dark gray)
- Use `renderStyledCard()` for complete styled output
- CSS dynamically injected into Shadow DOM via style element

Style options:
```typescript
{
  css: ".card { background: navy; }",  // Custom CSS
  includeDefaultStyles: true,          // Add DEFAULT_ANKI_CSS
  nightMode: true,                     // Add NIGHT_MODE_CSS + nightMode class
}
```
